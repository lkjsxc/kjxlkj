//! :mksession and :source command handlers.

use crate::editor::EditorState;

impl EditorState {
    /// Handle :mksession [file] — save session file.
    pub(crate) fn handle_mksession(&mut self, path: Option<&str>) {
        let path = path.unwrap_or("Session.vim");
        let mut lines = Vec::new();
        lines.push("\" Session file generated by kjxlkj".to_string());
        // Save buffer list with cursor positions.
        let focused_cursor = self.windows.focused().cursor;
        let focused_buf = self.current_buffer_id();
        for buf in self.buffers.iter() {
            if let Some(ref p) = buf.path {
                lines.push(format!("edit {}", p.display()));
                if buf.id == focused_buf {
                    lines.push(format!(
                        "call cursor({}, {})",
                        focused_cursor.line + 1,
                        focused_cursor.grapheme + 1
                    ));
                }
            }
        }
        // Save global marks.
        let bid = self.current_buffer_id().0 as usize;
        for (name, pos) in self.marks.list_for_buffer(bid) {
            if name.is_ascii_uppercase() {
                lines.push(format!("mark {} {} {}", name, pos.line + 1, pos.col + 1));
            }
        }
        // Save local marks per buffer.
        for buf in self.buffers.iter() {
            let bid = buf.id.0 as usize;
            for (name, pos) in self.marks.list_for_buffer(bid) {
                if name.is_ascii_lowercase() {
                    if let Some(ref p) = buf.path {
                        lines.push(format!("\" localmark {} {} {} {}", p.display(), name, pos.line + 1, pos.col + 1));
                    }
                }
            }
        }
        // Save editor options that differ from defaults.
        for (name, val) in self.options.list() {
            lines.push(format!("set {}={}", name, val));
        }
        // Save command-line history.
        for entry in &self.cmdline.history {
            lines.push(format!("\" history: {}", entry));
        }
        // Save search pattern.
        if let Some(ref pat) = self.search.pattern {
            lines.push(format!("\" search: {}", pat));
        }
        // Save window layout.
        self.serialize_layout(&self.windows.layout().clone(), &mut lines);
        let content = lines.join("\n") + "\n";
        match std::fs::write(path, content) {
            Ok(()) => self.notify_info(&format!("Session saved: {path}")),
            Err(e) => self.notify_error(&format!("E138: Cannot write: {e}")),
        }
    }

    /// Serialize layout tree as session commands.
    fn serialize_layout(&self, node: &kjxlkj_core_types::LayoutNode, lines: &mut Vec<String>) {
        use kjxlkj_core_types::{ContentSource, LayoutNode};
        match node {
            LayoutNode::Leaf(wid) => {
                if let Some(ws) = self.windows.get(*wid) {
                    if let ContentSource::Buffer(bid) = &ws.content {
                        if let Some(buf) = self.buffers.get(*bid) {
                            if let Some(ref p) = buf.path {
                                lines.push(format!("b {}", p.display()));
                            }
                        }
                    }
                }
            }
            LayoutNode::HorizontalSplit { children, weights } => {
                let ws: Vec<String> = weights.iter().map(|w| format!("{w:.4}")).collect();
                lines.push(format!("\" hsplit-weights: {}", ws.join(",")));
                for (i, child) in children.iter().enumerate() {
                    if i > 0 { lines.push("split".to_string()); }
                    self.serialize_layout(child, lines);
                }
            }
            LayoutNode::VerticalSplit { children, weights } => {
                let ws: Vec<String> = weights.iter().map(|w| format!("{w:.4}")).collect();
                lines.push(format!("\" vsplit-weights: {}", ws.join(",")));
                for (i, child) in children.iter().enumerate() {
                    if i > 0 { lines.push("vsplit".to_string()); }
                    self.serialize_layout(child, lines);
                }
            }
        }
    }

    /// Handle :source {file} — read and execute script commands.
    #[rustfmt::skip]
    pub(crate) fn handle_source(&mut self, path: &str) {
        let content = match std::fs::read_to_string(path) {
            Ok(c) => c, Err(e) => { self.notify_error(&format!("E484: {path}: {e}")); return; }
        };
        let all_lines: Vec<&str> = content.lines().collect();
        let (mut i, mut skip_stack) = (0usize, Vec::<bool>::new());
        let mut while_stack: Vec<(usize, String)> = Vec::new(); // (line_idx, cond_expr)
        let mut try_stack: Vec<bool> = Vec::new(); // true = in catch/error state
        while i < all_lines.len() {
            let trimmed = all_lines[i].trim(); i += 1;
            if trimmed.is_empty() { continue; }
            if trimmed == "finish" { break; }
            if let Some(ce) = trimmed.strip_prefix("if ") {
                let val = crate::expr_eval::eval_expression(ce.trim()).unwrap_or_default();
                skip_stack.push(val == "0" || val.is_empty()); continue;
            }
            if let Some(ce) = trimmed.strip_prefix("elseif ") {
                if let Some(top) = skip_stack.last_mut() {
                    if *top { let val = crate::expr_eval::eval_expression(ce.trim()).unwrap_or_default(); *top = val == "0" || val.is_empty(); }
                    else { *top = true; }
                } continue;
            }
            if trimmed == "else" { if let Some(top) = skip_stack.last_mut() { *top = !*top; } continue; }
            if trimmed == "endif" { skip_stack.pop(); continue; }
            if let Some(ce) = trimmed.strip_prefix("while ") {
                let val = crate::expr_eval::eval_expression(ce.trim()).unwrap_or_default();
                if val == "0" || val.is_empty() { skip_stack.push(true); while_stack.push((i, String::new())); }
                else { while_stack.push((i, ce.trim().to_string())); }
                continue;
            }
            if trimmed == "endwhile" {
                if let Some((start, cond)) = while_stack.pop() {
                    if !cond.is_empty() {
                        let val = crate::expr_eval::eval_expression(&cond).unwrap_or_default();
                        if val != "0" && !val.is_empty() { i = start; while_stack.push((start, cond)); continue; }
                    } else { skip_stack.pop(); }
                } continue;
            }
            if trimmed == "try" { try_stack.push(false); continue; }
            if trimmed.starts_with("catch") { if let Some(t) = try_stack.last_mut() { *t = !*t; } continue; }
            if trimmed == "finally" { if let Some(t) = try_stack.last_mut() { *t = false; } continue; }
            if trimmed == "endtry" { try_stack.pop(); continue; }
            if try_stack.last() == Some(&true) { continue; } // skip catch body when no error
            if skip_stack.iter().any(|&s| s) { continue; }
            if let Some(e) = trimmed.strip_prefix("\" history: ") { self.cmdline.history.push(e.to_string()); continue; }
            if let Some(p) = trimmed.strip_prefix("\" search: ") { self.search.pattern = Some(p.to_string()); continue; }
            if let Some(r) = trimmed.strip_prefix("\" localmark ") { self.source_restore_localmark(r); continue; }
            if trimmed.starts_with('"') { continue; }
            self.execute_ex_command(trimmed);
        }
        self.notify_info(&format!("Sourced: {path}"));
    }

    /// Restore a local mark from source comment.
    fn source_restore_localmark(&mut self, rest: &str) {
        let ps: Vec<&str> = rest.splitn(4, ' ').collect();
        if ps.len() == 4 {
            if let (Some(ch), Ok(l), Ok(c)) = (ps[1].chars().next(), ps[2].parse::<usize>(), ps[3].parse::<usize>()) {
                let bid = self.current_buffer_id().0 as usize;
                self.marks.set(ch, crate::marks::MarkPosition::new(bid, l.saturating_sub(1), c.saturating_sub(1)));
            }
        }
    }

    /// Handle :call cursor(line, col) — set cursor position.
    pub(crate) fn handle_call_cursor(&mut self, cmd: &str) {
        let inner = cmd
            .strip_prefix("call cursor(")
            .and_then(|s| s.strip_suffix(')'));
        if let Some(args) = inner {
            let parts: Vec<&str> = args.split(',').map(|s| s.trim()).collect();
            if parts.len() == 2 {
                let line = parts[0].parse::<usize>().unwrap_or(1).saturating_sub(1);
                let col = parts[1].parse::<usize>().unwrap_or(1).saturating_sub(1);
                self.windows.focused_mut().cursor.line = line;
                self.windows.focused_mut().cursor.grapheme = col;
                self.clamp_cursor();
                self.ensure_cursor_visible();
            }
        }
    }

    /// Handle :mark command — `mark X` or `mark X line col` (session restore).
    pub(crate) fn handle_mark_command(&mut self, rest: &str) {
        let parts: Vec<&str> = rest.split_whitespace().collect();
        let name = match parts.get(1).and_then(|s| s.chars().next()) {
            Some(c) => c,
            None => return,
        };
        if parts.len() >= 4 {
            let l = parts[2].parse::<usize>().unwrap_or(1).saturating_sub(1);
            let c = parts[3].parse::<usize>().unwrap_or(1).saturating_sub(1);
            let bid = self.current_buffer_id().0 as usize;
            self.marks.set(name, crate::marks::MarkPosition::new(bid, l, c));
        } else {
            self.handle_set_mark(name);
        }
    }
}
