//! :mksession and :source command handlers.

use crate::editor::EditorState;

impl EditorState {
    /// Handle :mksession [file] — save session file.
    pub(crate) fn handle_mksession(&mut self, path: Option<&str>) {
        let path = path.unwrap_or("Session.vim");
        let mut lines = Vec::new();
        lines.push("\" Session file generated by kjxlkj".to_string());
        // Save buffer list with cursor positions.
        let focused_cursor = self.windows.focused().cursor;
        let focused_buf = self.current_buffer_id();
        for buf in self.buffers.iter() {
            if let Some(ref p) = buf.path {
                lines.push(format!("edit {}", p.display()));
                if buf.id == focused_buf {
                    lines.push(format!(
                        "call cursor({}, {})",
                        focused_cursor.line + 1,
                        focused_cursor.grapheme + 1
                    ));
                }
            }
        }
        // Save window layout.
        self.serialize_layout(&self.windows.layout().clone(), &mut lines);
        let content = lines.join("\n") + "\n";
        match std::fs::write(path, content) {
            Ok(()) => self.notify_info(&format!("Session saved: {path}")),
            Err(e) => self.notify_error(&format!("E138: Cannot write: {e}")),
        }
    }

    /// Serialize layout tree as session commands.
    fn serialize_layout(&self, node: &kjxlkj_core_types::LayoutNode, lines: &mut Vec<String>) {
        use kjxlkj_core_types::LayoutNode;
        match node {
            LayoutNode::Leaf(_) => {}
            LayoutNode::HorizontalSplit { children, .. } => {
                for (i, child) in children.iter().enumerate() {
                    if i > 0 {
                        lines.push("split".to_string());
                    }
                    self.serialize_layout(child, lines);
                }
            }
            LayoutNode::VerticalSplit { children, .. } => {
                for (i, child) in children.iter().enumerate() {
                    if i > 0 {
                        lines.push("vsplit".to_string());
                    }
                    self.serialize_layout(child, lines);
                }
            }
        }
    }

    /// Handle :source {file} — read and execute commands.
    pub(crate) fn handle_source(&mut self, path: &str) {
        let content = match std::fs::read_to_string(path) {
            Ok(c) => c,
            Err(e) => {
                self.notify_error(&format!("E484: {path}: {e}"));
                return;
            }
        };
        for line in content.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() || trimmed.starts_with('"') {
                continue;
            }
            self.execute_ex_command(trimmed);
        }
    }

    /// Handle :call cursor(line, col) — set cursor position.
    pub(crate) fn handle_call_cursor(&mut self, cmd: &str) {
        let inner = cmd
            .strip_prefix("call cursor(")
            .and_then(|s| s.strip_suffix(')'));
        if let Some(args) = inner {
            let parts: Vec<&str> = args.split(',').map(|s| s.trim()).collect();
            if parts.len() == 2 {
                let line = parts[0].parse::<usize>().unwrap_or(1).saturating_sub(1);
                let col = parts[1].parse::<usize>().unwrap_or(1).saturating_sub(1);
                self.windows.focused_mut().cursor.line = line;
                self.windows.focused_mut().cursor.grapheme = col;
                self.clamp_cursor();
                self.ensure_cursor_visible();
            }
        }
    }
}
