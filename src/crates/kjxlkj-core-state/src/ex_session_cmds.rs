//! :mksession and :source command handlers.

use crate::editor::EditorState;

impl EditorState {
    /// Handle :mksession [file] — save session file.
    pub(crate) fn handle_mksession(&mut self, path: Option<&str>) {
        let path = path.unwrap_or("Session.vim");
        let mut lines = Vec::new();
        lines.push("\" Session file generated by kjxlkj".to_string());
        // Save buffer list with cursor positions.
        let focused_cursor = self.windows.focused().cursor;
        let focused_buf = self.current_buffer_id();
        for buf in self.buffers.iter() {
            if let Some(ref p) = buf.path {
                lines.push(format!("edit {}", p.display()));
                if buf.id == focused_buf {
                    lines.push(format!(
                        "call cursor({}, {})",
                        focused_cursor.line + 1,
                        focused_cursor.grapheme + 1
                    ));
                }
            }
        }
        // Save global marks.
        let bid = self.current_buffer_id().0 as usize;
        for (name, pos) in self.marks.list_for_buffer(bid) {
            if name.is_ascii_uppercase() {
                lines.push(format!("mark {} {} {}", name, pos.line + 1, pos.col + 1));
            }
        }
        // Save editor options that differ from defaults.
        for (name, val) in self.options.list() {
            lines.push(format!("set {}={}", name, val));
        }
        // Save command-line history.
        for entry in &self.cmdline.history {
            lines.push(format!("\" history: {}", entry));
        }
        // Save search pattern.
        if let Some(ref pat) = self.search.pattern {
            lines.push(format!("\" search: {}", pat));
        }
        // Save window layout.
        self.serialize_layout(&self.windows.layout().clone(), &mut lines);
        let content = lines.join("\n") + "\n";
        match std::fs::write(path, content) {
            Ok(()) => self.notify_info(&format!("Session saved: {path}")),
            Err(e) => self.notify_error(&format!("E138: Cannot write: {e}")),
        }
    }

    /// Serialize layout tree as session commands.
    fn serialize_layout(&self, node: &kjxlkj_core_types::LayoutNode, lines: &mut Vec<String>) {
        use kjxlkj_core_types::{ContentSource, LayoutNode};
        match node {
            LayoutNode::Leaf(wid) => {
                if let Some(ws) = self.windows.get(*wid) {
                    if let ContentSource::Buffer(bid) = &ws.content {
                        if let Some(buf) = self.buffers.get(*bid) {
                            if let Some(ref p) = buf.path {
                                lines.push(format!("b {}", p.display()));
                            }
                        }
                    }
                }
            }
            LayoutNode::HorizontalSplit { children, .. } => {
                for (i, child) in children.iter().enumerate() {
                    if i > 0 {
                        lines.push("split".to_string());
                    }
                    self.serialize_layout(child, lines);
                }
            }
            LayoutNode::VerticalSplit { children, .. } => {
                for (i, child) in children.iter().enumerate() {
                    if i > 0 {
                        lines.push("vsplit".to_string());
                    }
                    self.serialize_layout(child, lines);
                }
            }
        }
    }

    /// Handle :source {file} — read and execute commands.
    pub(crate) fn handle_source(&mut self, path: &str) {
        let content = match std::fs::read_to_string(path) {
            Ok(c) => c,
            Err(e) => {
                self.notify_error(&format!("E484: {path}: {e}"));
                return;
            }
        };
        for line in content.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }
            // Restore session history/search from special comments.
            if let Some(entry) = trimmed.strip_prefix("\" history: ") {
                self.cmdline.history.push(entry.to_string());
                continue;
            }
            if let Some(pat) = trimmed.strip_prefix("\" search: ") {
                self.search.pattern = Some(pat.to_string());
                continue;
            }
            if trimmed.starts_with('"') {
                continue;
            }
            self.execute_ex_command(trimmed);
        }
    }

    /// Handle :call cursor(line, col) — set cursor position.
    pub(crate) fn handle_call_cursor(&mut self, cmd: &str) {
        let inner = cmd
            .strip_prefix("call cursor(")
            .and_then(|s| s.strip_suffix(')'));
        if let Some(args) = inner {
            let parts: Vec<&str> = args.split(',').map(|s| s.trim()).collect();
            if parts.len() == 2 {
                let line = parts[0].parse::<usize>().unwrap_or(1).saturating_sub(1);
                let col = parts[1].parse::<usize>().unwrap_or(1).saturating_sub(1);
                self.windows.focused_mut().cursor.line = line;
                self.windows.focused_mut().cursor.grapheme = col;
                self.clamp_cursor();
                self.ensure_cursor_visible();
            }
        }
    }

    /// Handle :mark command — `mark X` or `mark X line col` (session restore).
    pub(crate) fn handle_mark_command(&mut self, rest: &str) {
        let parts: Vec<&str> = rest.split_whitespace().collect();
        let name = match parts.get(1).and_then(|s| s.chars().next()) {
            Some(c) => c,
            None => return,
        };
        if parts.len() >= 4 {
            let l = parts[2].parse::<usize>().unwrap_or(1).saturating_sub(1);
            let c = parts[3].parse::<usize>().unwrap_or(1).saturating_sub(1);
            let bid = self.current_buffer_id().0 as usize;
            self.marks.set(
                name,
                crate::marks::MarkPosition {
                    buffer_id: bid,
                    line: l,
                    col: c,
                },
            );
        } else {
            self.handle_set_mark(name);
        }
    }
}
