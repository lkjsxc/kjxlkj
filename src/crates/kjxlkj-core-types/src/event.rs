//! Event and intent types for editor communication.

use crate::{Mode, Position};
use serde::{Deserialize, Serialize};

/// Key modifiers for key events.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]
pub struct KeyModifiers {
    /// Control key is pressed.
    pub ctrl: bool,
    /// Alt/Meta key is pressed.
    pub alt: bool,
    /// Shift key is pressed.
    pub shift: bool,
    /// Super/Meta key is pressed.
    pub meta: bool,
}

impl KeyModifiers {
    /// No modifiers.
    pub const NONE: Self = Self {
        ctrl: false,
        alt: false,
        shift: false,
        meta: false,
    };

    /// Control modifier only.
    pub const CTRL: Self = Self {
        ctrl: true,
        alt: false,
        shift: false,
        meta: false,
    };

    /// Alt modifier only.
    pub const ALT: Self = Self {
        ctrl: false,
        alt: true,
        shift: false,
        meta: false,
    };

    /// Shift modifier only.
    pub const SHIFT: Self = Self {
        ctrl: false,
        alt: false,
        shift: true,
        meta: false,
    };

    /// Check if any modifier is pressed.
    pub fn any(&self) -> bool {
        self.ctrl || self.alt || self.shift || self.meta
    }
}

/// A key code representing a keyboard key.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum KeyCode {
    /// A character key.
    Char(char),
    /// Escape key.
    Escape,
    /// Enter/Return key.
    Enter,
    /// Backspace key.
    Backspace,
    /// Tab key.
    Tab,
    /// BackTab (Shift+Tab).
    BackTab,
    /// Left arrow.
    Left,
    /// Right arrow.
    Right,
    /// Up arrow.
    Up,
    /// Down arrow.
    Down,
    /// Home key.
    Home,
    /// End key.
    End,
    /// Page up.
    PageUp,
    /// Page down.
    PageDown,
    /// Delete key.
    Delete,
    /// Insert key.
    Insert,
    /// Function key F1-F12.
    F(u8),
    /// Null key.
    Null,
    /// Caps lock.
    CapsLock,
    /// Scroll lock.
    ScrollLock,
    /// Num lock.
    NumLock,
    /// Print screen.
    PrintScreen,
    /// Pause.
    Pause,
    /// Menu key.
    Menu,
    /// Keypad begin.
    KeypadBegin,
    /// Media key.
    Media(String),
    /// Modifier key.
    Modifier(String),
}

impl KeyCode {
    /// Parse a key code from a string.
    pub fn from_str_loose(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "escape" | "esc" => Some(KeyCode::Escape),
            "enter" | "return" | "cr" => Some(KeyCode::Enter),
            "backspace" | "bs" => Some(KeyCode::Backspace),
            "tab" => Some(KeyCode::Tab),
            "left" => Some(KeyCode::Left),
            "right" => Some(KeyCode::Right),
            "up" => Some(KeyCode::Up),
            "down" => Some(KeyCode::Down),
            "home" => Some(KeyCode::Home),
            "end" => Some(KeyCode::End),
            "pageup" => Some(KeyCode::PageUp),
            "pagedown" => Some(KeyCode::PageDown),
            "delete" | "del" => Some(KeyCode::Delete),
            "insert" | "ins" => Some(KeyCode::Insert),
            s if s.len() == 1 => s.chars().next().map(KeyCode::Char),
            _ => None,
        }
    }
}

/// A key event from the terminal.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct KeyEvent {
    /// The key code.
    pub code: KeyCode,
    /// Key modifiers.
    pub modifiers: KeyModifiers,
}

impl KeyEvent {
    /// Create a new key event.
    pub fn new(code: KeyCode, modifiers: KeyModifiers) -> Self {
        Self { code, modifiers }
    }

    /// Create a key event with no modifiers.
    pub fn plain(code: KeyCode) -> Self {
        Self::new(code, KeyModifiers::NONE)
    }

    /// Create a character key event.
    pub fn char(c: char) -> Self {
        Self::plain(KeyCode::Char(c))
    }

    /// Create a key event with control modifier.
    pub fn ctrl(code: KeyCode) -> Self {
        Self::new(code, KeyModifiers::CTRL)
    }
}

/// Events that can occur in the editor.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum EditorEvent {
    /// A key was pressed.
    Key(KeyEvent),
    /// Terminal was resized.
    Resize { width: u16, height: u16 },
    /// Request to quit.
    Quit,
    /// Focus changed.
    Focus(bool),
    /// Paste text.
    Paste(String),
    /// Ignored event.
    Ignored,
}

/// Intents generated by mode handlers to be applied by the core.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Intent {
    /// Insert text at cursor.
    InsertText(String),
    /// Delete text (with motion description).
    Delete { linewise: bool, count: usize, motion: Option<MotionIntent> },
    /// Yank text to register.
    Yank { linewise: bool, count: usize, motion: Option<MotionIntent> },
    /// Change text (delete and enter insert mode).
    Change { linewise: bool, count: usize, motion: Option<MotionIntent> },
    /// Move cursor to position.
    MoveCursor(Position),
    /// Move cursor by motion.
    Motion(MotionIntent),
    /// Switch mode.
    SwitchMode(Mode),
    /// Execute Ex command.
    ExecuteCommand(String),
    /// Open a line below/above.
    OpenLine { below: bool },
    /// Undo last change.
    Undo,
    /// Redo last undone change.
    Redo,
    /// Join lines.
    JoinLines { add_space: bool },
    /// Indent lines.
    Indent,
    /// Outdent lines.
    Outdent,
    /// Toggle case.
    ToggleCase,
    /// Uppercase.
    Uppercase,
    /// Lowercase.
    Lowercase,
    /// Increment number.
    Increment(i64),
    /// Repeat last change.
    Repeat,
    /// Start/stop macro recording.
    MacroToggle(char),
    /// Play macro.
    MacroPlay(char),
    /// Set mark.
    SetMark(char),
    /// Jump to mark.
    JumpToMark { mark: char, first_non_blank: bool },
    /// Search forward.
    SearchForward(String),
    /// Search backward.
    SearchBackward(String),
    /// Next search match.
    NextMatch,
    /// Previous search match.
    PrevMatch,
    /// Scroll view.
    Scroll(ScrollIntent),
    /// Paste from register.
    Paste { before: bool, cursor_at_end: bool },
    /// Select register.
    SelectRegister(char),
    /// Replace character.
    ReplaceChar(char),
    /// Substitute character (delete and enter insert).
    Substitute,
    /// No operation.
    Nop,
}

/// Motion intents for cursor movement.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum MotionIntent {
    /// Move left.
    Left,
    /// Move right.
    Right,
    /// Move up.
    Up,
    /// Move down.
    Down,
    /// Move to line start (column 0).
    LineStart,
    /// Move to first non-blank.
    FirstNonBlank,
    /// Move to line end.
    LineEnd,
    /// Move to last non-blank.
    LastNonBlank,
    /// Move to next word start.
    WordStart,
    /// Move to next WORD start.
    WORDStart,
    /// Move to previous word start.
    WordStartBack,
    /// Move to previous WORD start.
    WORDStartBack,
    /// Move to word end.
    WordEnd,
    /// Move to WORD end.
    WORDEnd,
    /// Move to previous word end.
    WordEndBack,
    /// Move to previous WORD end.
    WORDEndBack,
    /// Move to file start.
    FileStart,
    /// Move to file end.
    FileEnd,
    /// Move to line N.
    GotoLine(usize),
    /// Move to percentage of file.
    GotoPercent(u8),
    /// Move to screen top.
    ScreenTop,
    /// Move to screen middle.
    ScreenMiddle,
    /// Move to screen bottom.
    ScreenBottom,
    /// Move to column N.
    GotoColumn(usize),
    /// Move to middle of line.
    LineMiddle,
    /// Find character forward.
    FindChar { c: char, inclusive: bool },
    /// Find character backward.
    FindCharBack { c: char, inclusive: bool },
    /// Repeat last find.
    RepeatFind,
    /// Repeat last find in opposite direction.
    RepeatFindBack,
    /// Move to next sentence.
    NextSentence,
    /// Move to previous sentence.
    PrevSentence,
    /// Move to next paragraph.
    NextParagraph,
    /// Move to previous paragraph.
    PrevParagraph,
    /// Move to matching bracket.
    MatchingBracket,
}

/// Scroll intents for viewport control.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ScrollIntent {
    /// Half page down.
    HalfPageDown,
    /// Half page up.
    HalfPageUp,
    /// Full page down.
    PageDown,
    /// Full page up.
    PageUp,
    /// Scroll line down (cursor stays).
    LineDown,
    /// Scroll line up (cursor stays).
    LineUp,
    /// Center cursor on screen.
    CenterCursor,
    /// Cursor to top of screen.
    CursorToTop,
    /// Cursor to bottom of screen.
    CursorToBottom,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_key_modifiers() {
        assert!(!KeyModifiers::NONE.any());
        assert!(KeyModifiers::CTRL.any());
        assert!(KeyModifiers::ALT.any());
    }

    #[test]
    fn test_key_code_from_str() {
        assert_eq!(KeyCode::from_str_loose("escape"), Some(KeyCode::Escape));
        assert_eq!(KeyCode::from_str_loose("Esc"), Some(KeyCode::Escape));
        assert_eq!(KeyCode::from_str_loose("enter"), Some(KeyCode::Enter));
        assert_eq!(KeyCode::from_str_loose("a"), Some(KeyCode::Char('a')));
    }

    #[test]
    fn test_key_event() {
        let ev = KeyEvent::char('a');
        assert_eq!(ev.code, KeyCode::Char('a'));
        assert_eq!(ev.modifiers, KeyModifiers::NONE);

        let ctrl_a = KeyEvent::ctrl(KeyCode::Char('a'));
        assert!(ctrl_a.modifiers.ctrl);
    }
}
