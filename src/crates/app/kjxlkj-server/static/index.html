<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>kjxlkj</title>
  <style>
    :root {
      color-scheme: light;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #f7f8fa;
      color: #151a23;
    }
    .topbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-bottom: 1px solid #dde2eb;
      background: #ffffff;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .topbar .spacer { flex: 1; }
    button, input, textarea {
      font: inherit;
    }
    button {
      border: 1px solid #c7cfdd;
      background: #fff;
      color: #1c2434;
      border-radius: 8px;
      padding: 6px 10px;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    input, textarea {
      width: 100%;
      border: 1px solid #c7cfdd;
      border-radius: 8px;
      padding: 8px;
      background: #fff;
      color: #101522;
    }
    .status {
      font-size: 12px;
      color: #364154;
      min-height: 18px;
    }
    .status.success { color: #046f46; }
    .status.error { color: #ab2134; }
    #authView {
      max-width: 460px;
      margin: 40px auto;
      padding: 16px;
      border: 1px solid #dde2eb;
      border-radius: 12px;
      background: #fff;
    }
    .auth-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .auth-panel { display: none; }
    .auth-panel.active { display: block; }
    .auth-grid {
      display: grid;
      gap: 8px;
    }
    #appView[hidden], #authView[hidden], #commandPalette[hidden] {
      display: none;
    }
    .shell {
      display: grid;
      grid-template-columns: minmax(240px, 320px) 1fr;
      height: calc(100vh - 48px);
    }
    .left-pane {
      border-right: 1px solid #dde2eb;
      background: #fff;
      overflow-y: auto;
      padding: 10px;
      display: grid;
      align-content: start;
      gap: 10px;
    }
    .right-pane {
      overflow-y: auto;
      padding: 12px;
      display: grid;
      align-content: start;
      gap: 10px;
    }
    .card {
      border: 1px solid #dde2eb;
      border-radius: 10px;
      padding: 10px;
      background: #fff;
    }
    .list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 6px;
    }
    .list button {
      width: 100%;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .active-item {
      border-color: #5f79ff;
      color: #21368b;
    }
    .workspace-controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
    }
    .editor {
      min-height: 52vh;
      resize: vertical;
      line-height: 1.5;
    }
    #commandPalette {
      position: fixed;
      inset: 0;
      background: rgba(18, 23, 32, 0.45);
      display: grid;
      place-items: start center;
      padding-top: 56px;
      z-index: 20;
    }
    .palette-box {
      width: min(680px, calc(100vw - 20px));
      border: 1px solid #d9dfeb;
      border-radius: 12px;
      background: #fff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .hint {
      font-size: 12px;
      color: #5c6982;
      display: grid;
      gap: 4px;
    }
    .nav-collapsed .left-pane {
      display: none;
    }
    .nav-collapsed .shell {
      grid-template-columns: 1fr;
    }
    @media (max-width: 640px) {
      .shell {
        grid-template-columns: 1fr;
      }
      .left-pane {
        max-height: 42vh;
        border-right: 0;
        border-bottom: 1px solid #dde2eb;
      }
      .right-pane {
        min-height: 56vh;
      }
      .workspace-controls {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="authView" hidden>
    <div class="auth-tabs">
      <button id="tabLogin" type="button">Login</button>
      <button id="tabSetup" type="button">Setup</button>
    </div>
    <div id="authStatus" class="status"></div>

    <form id="loginPanel" class="auth-panel auth-grid active">
      <input id="loginEmail" type="email" placeholder="Email" required />
      <input id="loginPassword" type="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>

    <form id="setupPanel" class="auth-panel auth-grid">
      <input id="setupEmail" type="email" placeholder="Owner email" required />
      <input id="setupName" type="text" placeholder="Display name" required />
      <input id="setupPassword" type="password" placeholder="Password" required />
      <input id="setupWorkspaceName" type="text" placeholder="Workspace name" />
      <button type="submit">Create owner</button>
    </form>
  </div>

  <div id="appView" hidden>
    <div class="topbar">
      <button id="menuToggle" type="button" aria-label="Toggle navigation">☰</button>
      <button id="paletteToggle" type="button">⌘/Ctrl+K</button>
      <div class="spacer"></div>
      <button id="contextBack" type="button" disabled>Back Context</button>
      <button id="logoutButton" type="button">Logout</button>
    </div>
    <div class="topbar" style="border-top:0; border-bottom:1px solid #dde2eb;">
      <div id="appStatus" class="status"></div>
    </div>

    <div id="shellContainer" class="shell">
      <aside class="left-pane">
        <div class="card">
          <div class="workspace-controls">
            <input id="workspaceId" placeholder="Workspace UUID" />
            <button id="loadWorkspace" type="button">Load</button>
          </div>
        </div>
        <div class="card">
          <strong>Notes</strong>
          <ul id="notesList" class="list"></ul>
        </div>
        <div class="card">
          <strong>Graph</strong>
          <ul id="backlinksList" class="list"></ul>
        </div>
      </aside>

      <main class="right-pane">
        <div class="card">
          <input id="noteTitle" placeholder="Note title" />
        </div>
        <div class="card">
          <textarea id="noteEditor" class="editor" placeholder="Start writing..."></textarea>
        </div>
      </main>
    </div>
  </div>

  <div id="commandPalette" hidden>
    <div class="palette-box">
      <input id="paletteInput" placeholder="create <title> | open <note-id> | move <project-id|none> | tag <tag1,tag2> | run-rule <id>" />
      <div class="hint">
        <div>Enter executes command, Esc closes.</div>
        <div>Commands use API-backed behavior with deterministic status feedback.</div>
      </div>
    </div>
  </div>

  <script>
    const state = {
      csrfToken: null,
      setupLocked: false,
      workspaceId: localStorage.getItem('workspace_id') || '',
      notes: [],
      currentNoteId: null,
      currentVersion: 0,
      currentMarkdown: '',
      contextStack: [],
      saveTimer: null,
      titleTimer: null,
    };

    const authView = document.getElementById('authView');
    const appView = document.getElementById('appView');
    const authStatus = document.getElementById('authStatus');
    const appStatus = document.getElementById('appStatus');
    const tabLogin = document.getElementById('tabLogin');
    const tabSetup = document.getElementById('tabSetup');
    const loginPanel = document.getElementById('loginPanel');
    const setupPanel = document.getElementById('setupPanel');
    const loginEmail = document.getElementById('loginEmail');
    const loginPassword = document.getElementById('loginPassword');
    const setupEmail = document.getElementById('setupEmail');
    const setupName = document.getElementById('setupName');
    const setupPassword = document.getElementById('setupPassword');
    const setupWorkspaceName = document.getElementById('setupWorkspaceName');
    const logoutButton = document.getElementById('logoutButton');
    const workspaceIdInput = document.getElementById('workspaceId');
    const loadWorkspaceButton = document.getElementById('loadWorkspace');
    const notesList = document.getElementById('notesList');
    const backlinksList = document.getElementById('backlinksList');
    const noteTitle = document.getElementById('noteTitle');
    const noteEditor = document.getElementById('noteEditor');
    const menuToggle = document.getElementById('menuToggle');
    const shellContainer = document.getElementById('shellContainer');
    const contextBack = document.getElementById('contextBack');
    const commandPalette = document.getElementById('commandPalette');
    const paletteToggle = document.getElementById('paletteToggle');
    const paletteInput = document.getElementById('paletteInput');

    function setStatus(target, text, type = 'info') {
      target.textContent = text;
      target.className = type === 'success' ? 'status success' : type === 'error' ? 'status error' : 'status';
    }

    function setAuthMode(mode) {
      loginPanel.classList.toggle('active', mode === 'login');
      setupPanel.classList.toggle('active', mode === 'setup' && !state.setupLocked);
      if (state.setupLocked) {
        tabSetup.hidden = true;
      }
    }

    function openPalette() {
      commandPalette.hidden = false;
      paletteInput.value = '';
      paletteInput.focus();
    }

    function closePalette() {
      commandPalette.hidden = true;
    }

    async function request(path, options = {}) {
      const response = await fetch(path, {
        credentials: 'include',
        ...options,
      });
      const isJson = (response.headers.get('content-type') || '').includes('application/json');
      const data = isJson ? await response.json() : null;
      return { ok: response.ok, status: response.status, data };
    }

    function mutationHeaders() {
      return {
        'content-type': 'application/json',
        'x-csrf-token': state.csrfToken || '',
      };
    }

    async function checkSession() {
      const session = await request('/api/auth/session');
      if (session.ok) {
        state.csrfToken = session.data.csrf_token;
        showApp();
        return;
      }
      showAuth();
    }

    function showAuth() {
      appView.hidden = true;
      authView.hidden = false;
      setAuthMode('login');
      setStatus(authStatus, state.setupLocked ? 'Setup is locked. Login only.' : 'Login or first-run setup.', 'info');
    }

    async function showApp() {
      authView.hidden = true;
      appView.hidden = false;
      workspaceIdInput.value = state.workspaceId;
      if (state.workspaceId) {
        await loadNotes();
      } else {
        setStatus(appStatus, 'Enter workspace UUID and load notes.', 'info');
      }
    }

    async function loadNotes() {
      state.workspaceId = workspaceIdInput.value.trim();
      localStorage.setItem('workspace_id', state.workspaceId);
      if (!state.workspaceId) {
        setStatus(appStatus, 'Workspace UUID is required.', 'error');
        return;
      }

      const response = await request(`/api/notes?workspace_id=${encodeURIComponent(state.workspaceId)}`);
      if (response.status === 401) {
        state.csrfToken = null;
        showAuth();
        return;
      }
      if (!response.ok) {
        setStatus(appStatus, `Failed to load notes (${response.status}).`, 'error');
        return;
      }

      state.notes = response.data.notes || [];
      renderNotes();
      if (state.currentNoteId && state.notes.find((item) => item.id === state.currentNoteId)) {
        await openNote(state.currentNoteId, false);
      } else if (state.notes.length > 0) {
        await openNote(state.notes[0].id, false);
      } else {
        state.currentNoteId = null;
        state.currentVersion = 0;
        state.currentMarkdown = '';
        noteTitle.value = '';
        noteEditor.value = '';
        backlinksList.innerHTML = '';
        setStatus(appStatus, 'No notes yet. Use command palette: create <title>.', 'info');
      }
    }

    function renderNotes() {
      notesList.innerHTML = '';
      for (const note of state.notes) {
        const li = document.createElement('li');
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = note.title || note.id;
        if (note.id === state.currentNoteId) {
          button.classList.add('active-item');
        }
        button.addEventListener('click', () => openNote(note.id, true));
        li.appendChild(button);
        notesList.appendChild(li);
      }
    }

    async function openNote(noteId, pushContext) {
      if (!noteId) {
        return;
      }
      if (pushContext && state.currentNoteId && state.currentNoteId !== noteId) {
        state.contextStack.push(state.currentNoteId);
        contextBack.disabled = state.contextStack.length === 0;
      }

      const response = await request(`/api/notes/${encodeURIComponent(noteId)}`);
      if (!response.ok) {
        setStatus(appStatus, `Open failed (${response.status}).`, 'error');
        return;
      }

      const payload = response.data;
      state.currentNoteId = payload.note_id;
      state.currentVersion = payload.version;
      state.currentMarkdown = payload.markdown || '';
      noteTitle.value = payload.title || '';
      noteEditor.value = payload.markdown || '';
      renderNotes();
      await refreshBacklinks();
      setStatus(appStatus, `Opened note ${state.currentNoteId}.`, 'success');
    }

    async function refreshBacklinks() {
      backlinksList.innerHTML = '';
      if (!state.currentNoteId) {
        return;
      }
      const response = await request(`/api/notes/${encodeURIComponent(state.currentNoteId)}/backlinks`);
      if (!response.ok) {
        return;
      }

      for (const link of response.data.backlinks || []) {
        const li = document.createElement('li');
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = link.target_title;
        button.addEventListener('click', () => openFromGraph(link.target_title));
        li.appendChild(button);
        backlinksList.appendChild(li);
      }
    }

    async function openFromGraph(targetTitle) {
      if (state.currentNoteId) {
        state.contextStack.push(state.currentNoteId);
        contextBack.disabled = state.contextStack.length === 0;
      }

      const local = state.notes.find((item) => item.title === targetTitle);
      if (local) {
        await openNote(local.id, false);
        return;
      }

      const search = await request(`/api/search?workspace_id=${encodeURIComponent(state.workspaceId)}&q=${encodeURIComponent(targetTitle)}`);
      if (!search.ok || !search.data.results || search.data.results.length === 0) {
        setStatus(appStatus, 'Graph target not found in this workspace.', 'error');
        return;
      }

      await openNote(search.data.results[0].note_id, false);
    }

    async function saveTitle() {
      if (!state.currentNoteId) {
        return;
      }
      const nextTitle = noteTitle.value.trim();
      const current = state.notes.find((item) => item.id === state.currentNoteId)?.title || '';
      if (!nextTitle || nextTitle === current) {
        return;
      }

      const response = await request(`/api/notes/${encodeURIComponent(state.currentNoteId)}/title`, {
        method: 'PATCH',
        headers: mutationHeaders(),
        body: JSON.stringify({
          base_version: state.currentVersion,
          title: nextTitle,
        }),
      });

      if (!response.ok) {
        setStatus(appStatus, `Title update failed (${response.status}).`, 'error');
        return;
      }

      state.currentVersion = response.data.version;
      const idx = state.notes.findIndex((item) => item.id === state.currentNoteId);
      if (idx >= 0) {
        state.notes[idx].title = nextTitle;
      }
      renderNotes();
      setStatus(appStatus, 'Title updated.', 'success');
    }

    async function saveMarkdown() {
      if (!state.currentNoteId) {
        return;
      }
      const nextMarkdown = noteEditor.value;
      if (nextMarkdown === state.currentMarkdown) {
        return;
      }

      const patchOps = [];
      if (state.currentMarkdown.length > 0) {
        patchOps.push({ delete: state.currentMarkdown.length });
      }
      if (nextMarkdown.length > 0) {
        patchOps.push({ insert: nextMarkdown });
      }
      if (patchOps.length === 0) {
        return;
      }

      const response = await request(`/api/notes/${encodeURIComponent(state.currentNoteId)}`, {
        method: 'PATCH',
        headers: mutationHeaders(),
        body: JSON.stringify({
          base_version: state.currentVersion,
          patch_ops: patchOps,
          idempotency_key: `ui-${Date.now()}-${Math.random().toString(16).slice(2)}`,
        }),
      });

      if (response.status === 409) {
        setStatus(appStatus, 'Conflict detected. Refreshing note.', 'error');
        await openNote(state.currentNoteId, false);
        return;
      }
      if (!response.ok) {
        setStatus(appStatus, `Autosave failed (${response.status}).`, 'error');
        return;
      }

      state.currentVersion = response.data.version;
      state.currentMarkdown = nextMarkdown;
      setStatus(appStatus, 'Autosaved.', 'success');
    }

    async function executeCommand(text) {
      const raw = text.trim();
      if (!raw) {
        return;
      }

      const [command, ...args] = raw.split(' ');
      const value = args.join(' ').trim();

      if (command === 'create') {
        if (!state.workspaceId) {
          setStatus(appStatus, 'Set workspace UUID before create.', 'error');
          return;
        }
        const title = value || 'Untitled';
        const response = await request('/api/notes', {
          method: 'POST',
          headers: mutationHeaders(),
          body: JSON.stringify({
            workspace_id: state.workspaceId,
            project_id: null,
            title,
            note_kind: 'markdown',
            access_scope: 'workspace',
            markdown: '',
          }),
        });
        if (!response.ok) {
          setStatus(appStatus, `Create failed (${response.status}).`, 'error');
          return;
        }
        await loadNotes();
        await openNote(response.data.note_id, false);
        setStatus(appStatus, 'Create succeeded.', 'success');
        return;
      }

      if (command === 'open') {
        if (!value) {
          setStatus(appStatus, 'Open requires note id.', 'error');
          return;
        }
        await openNote(value, true);
        return;
      }

      if (command === 'move') {
        if (!state.currentNoteId) {
          setStatus(appStatus, 'Open a note before move.', 'error');
          return;
        }
        const response = await request(`/api/notes/${encodeURIComponent(state.currentNoteId)}/metadata/project.move`, {
          method: 'PUT',
          headers: mutationHeaders(),
          body: JSON.stringify({ project_id: value || null }),
        });
        if (!response.ok) {
          setStatus(appStatus, `Move failed (${response.status}).`, 'error');
          return;
        }
        setStatus(appStatus, 'Move command recorded.', 'success');
        return;
      }

      if (command === 'tag') {
        if (!state.currentNoteId) {
          setStatus(appStatus, 'Open a note before tag.', 'error');
          return;
        }
        const tags = value
          .split(',')
          .map((item) => item.trim())
          .filter((item) => item.length > 0);
        const response = await request(`/api/notes/${encodeURIComponent(state.currentNoteId)}/tags`, {
          method: 'PUT',
          headers: mutationHeaders(),
          body: JSON.stringify({ tags }),
        });
        if (!response.ok) {
          setStatus(appStatus, `Tag failed (${response.status}).`, 'error');
          return;
        }
        setStatus(appStatus, 'Tag command succeeded.', 'success');
        return;
      }

      if (command === 'run-rule') {
        const response = await request('/api/automation/rules');
        if (!response.ok) {
          setStatus(appStatus, `Run-rule failed (${response.status}) with deterministic API feedback.`, 'error');
          return;
        }
        setStatus(appStatus, 'Run-rule command executed.', 'success');
        return;
      }

      setStatus(appStatus, `Unknown command: ${command}`, 'error');
    }

    tabLogin.addEventListener('click', () => setAuthMode('login'));
    tabSetup.addEventListener('click', () => setAuthMode('setup'));

    loginPanel.addEventListener('submit', async (event) => {
      event.preventDefault();
      const response = await request('/api/auth/login', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          email: loginEmail.value.trim(),
          password: loginPassword.value,
        }),
      });
      if (!response.ok) {
        setStatus(authStatus, `Login failed (${response.status}).`, 'error');
        return;
      }
      state.csrfToken = response.data.csrf_token;
      await showApp();
    });

    setupPanel.addEventListener('submit', async (event) => {
      event.preventDefault();
      const response = await request('/api/setup/register', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          email: setupEmail.value.trim(),
          display_name: setupName.value.trim(),
          password: setupPassword.value,
          workspace_name: setupWorkspaceName.value.trim() || null,
        }),
      });
      if (response.status === 409) {
        state.setupLocked = true;
        setAuthMode('login');
        setStatus(authStatus, 'Setup is locked. Login-only UI is active.', 'error');
        return;
      }
      if (!response.ok) {
        setStatus(authStatus, `Setup failed (${response.status}).`, 'error');
        return;
      }
      state.csrfToken = response.data.csrf_token;
      state.workspaceId = response.data.workspace_id || '';
      localStorage.setItem('workspace_id', state.workspaceId);
      await showApp();
    });

    logoutButton.addEventListener('click', async () => {
      await request('/api/auth/logout', {
        method: 'POST',
        headers: mutationHeaders(),
      });
      state.csrfToken = null;
      state.currentNoteId = null;
      state.currentVersion = 0;
      state.currentMarkdown = '';
      state.notes = [];
      state.contextStack = [];
      contextBack.disabled = true;
      showAuth();
    });

    loadWorkspaceButton.addEventListener('click', loadNotes);

    noteEditor.addEventListener('input', () => {
      clearTimeout(state.saveTimer);
      state.saveTimer = setTimeout(() => {
        saveMarkdown();
      }, 500);
    });

    noteTitle.addEventListener('input', () => {
      clearTimeout(state.titleTimer);
      state.titleTimer = setTimeout(() => {
        saveTitle();
      }, 400);
    });

    noteTitle.addEventListener('blur', () => saveTitle());

    menuToggle.addEventListener('click', () => {
      document.body.classList.toggle('nav-collapsed');
    });

    contextBack.addEventListener('click', async () => {
      if (state.contextStack.length === 0) {
        contextBack.disabled = true;
        return;
      }
      const previous = state.contextStack.pop();
      contextBack.disabled = state.contextStack.length === 0;
      await openNote(previous, false);
    });

    paletteToggle.addEventListener('click', () => {
      if (commandPalette.hidden) {
        openPalette();
      } else {
        closePalette();
      }
    });

    paletteInput.addEventListener('keydown', async (event) => {
      if (event.key === 'Escape') {
        closePalette();
        return;
      }
      if (event.key === 'Enter') {
        const value = paletteInput.value;
        closePalette();
        await executeCommand(value);
      }
    });

    commandPalette.addEventListener('click', (event) => {
      if (event.target === commandPalette) {
        closePalette();
      }
    });

    document.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'k') {
        event.preventDefault();
        if (commandPalette.hidden) {
          openPalette();
        } else {
          closePalette();
        }
      }
      if (event.key === 'Escape' && !commandPalette.hidden) {
        closePalette();
      }
    });

    checkSession();
  </script>
</body>
</html>
